#if !defined(__circle_lang__) || (__circle_build__ < 146)
  #error Must compile with Circle build 146 or later
#endif

#include <iostream>
#include <memory>
#include <cassert>
#include <array>
#include <limits>
#include <type_traits>

namespace std {
namespace experimental {

using std::array;

constexpr size_t dynamic_extent = size_t.max;

// [mdspan.extents], class template extents
template<size_t... Extents>
class extents;

// Spam out dynamic_extent Rank times.
template<size_t Rank>
using dextents = extents<for i : Rank => dynamic_extent>;

template<class>
constexpr size_t make_dynamic_extent() { return dynamic_extent; } 

// The Index template parameter is required so that each data member is 
// of a different type, allowing the [[no_unique_address]] attribute
// to map them all to the same struct offset.

template<typename Type>
concept SizeType = std::is_convertible_v<Type, size_t>;

template<size_t Index, size_t Extent>
struct _storage_t {
  constexpr _storage_t(size_t value = Extent) noexcept { 
    assert(value == extent);
  }
  static constexpr size_t extent = Extent;
};

template<size_t Index>
struct _storage_t<Index, dynamic_extent> {
  constexpr _storage_t(size_t value = 1) noexcept : extent(value) { }
  size_t extent;
};

template<size_t... Extents>
struct extents {
  using size_type = size_t;

  static constexpr size_t rank() noexcept { return sizeof... Extents; }
  static constexpr size_t rank_dynamic() noexcept {
    return (0 + ... + (Extents == dynamic_extent));
  }

  // Set the runtime extents to 1.
  constexpr extents() = default;

  template<size_t... OtherExtents>
  requires((... && 
    (
      Extents == dynamic_extent ||
      OtherExtents == dynamic_extent ||
      Extents == OtherExtents
    )
  ))
  explicit((... ||
    (
      Extents != dynamic_extent &&
      OtherExtents == dynamic_extent
    )
  ))
  constexpr extents(const extents<OtherExtents...>& other) :
    m(other. ...m.extent)... { }

  // One index per extent.
  template<SizeType... IndexTypes>
  requires(sizeof...(IndexTypes) == rank())
  explicit constexpr extents(IndexTypes... exts) noexcept :
    m(exts)... { }

  // Map index I to dynamic index J.
  template<size_t I>
  static constexpr size_t find_dynamic_index = 
    (0 + ... + (dynamic_extent == Extents...[:I]));

  // One index per dynamic extent.
  template<SizeType... IndexTypes> requires(
    sizeof...(IndexTypes) != rank() && 
    sizeof...(IndexTypes) == rank_dynamic()
  )
  explicit constexpr extents(IndexTypes... exts) noexcept : m(
    dynamic_extent == Extents ?? 
      exts...[find_dynamic_index<int...>] : 
      Extents
  )... { }

  template<SizeType IndexType, size_t N>
  requires(N == rank() || N == rank_dynamic())
  explicit(N != rank_dynamic())
  constexpr extents(const std::array<IndexType, N>& exts) noexcept :
    extents(exts...) { }

  template<int I>
  constexpr size_t get() const noexcept {
    return m...[I].extent;
  }

  constexpr size_t extent(size_t n) const noexcept {
    return n == int... ...? m.extent : 0;
  }

  // Create partially static storage for the dynamic extents.
  [[no_unique_address]] _storage_t<int..., Extents> m ...;
};

struct layout_left;
struct layout_right;
struct layout_stride;

struct layout_right {
  template <class Extents>
  class mapping {
  private:

    static_assert(extents == Extents.template, 
      "layout_right::mapping must be instantiated with extents");

    template <class>
    friend class mapping;

    template<typename... Indices>
    constexpr size_t compute_offset(Indices... indices) const noexcept {
      static_assert(sizeof...(Indices) == Extents::rank());

      // The right-most extent is the most quickly varying.
      size_t x = 0;
      @meta for(int i : sizeof...(Indices)) {
        @meta if(i != 0)
          x *= _extents.template get<i>();
        x += indices...[i];
      }
      return x;
    }

  public:
    constexpr mapping() noexcept = default;
    constexpr mapping(mapping const&) noexcept = default;
    constexpr mapping(mapping&&) noexcept = default;
    constexpr mapping& operator=(mapping const&) noexcept = default;
    constexpr mapping& operator=(mapping&&) noexcept = default;

    using layout_type = layout_right;
    using extents_type = Extents;
    using size_type = typename Extents::size_type;

    constexpr mapping(const Extents& extents) noexcept
      : _extents(extents) { }

    template<typename OtherExtents>
    requires(std::is_constructible_v<Extents, OtherExtents>)
    explicit(!std::is_convertible_v<OtherExtents, Extents>)
    constexpr mapping(const mapping<OtherExtents>& other) noexcept :
      _extents(other.extents()) { }

    // Convert from layout_left
    template<typename OtherMapping>
    requires(
      std::is_constructible_v<Extents, typename OtherMapping::extents_type> &&
      typename OtherMapping::layout_type == layout_left &&
      Extents::rank() <= 1
    )
    explicit(!std::is_convertible_v<typename OtherMapping::extents_type, Extents>)
    constexpr mapping(const OtherMapping& other) noexcept :
      _extents(other.extents()) { }

    // Convert from layout_stride
    template<typename OtherMapping>
    requires(
      std::is_constructible_v<Extents, typename OtherMapping::extents_type> &&
      typename OtherMapping::layout_type == layout_stride
    )
    explicit(Extents::rank() != 0)
    constexpr mapping(const OtherMapping& other) noexcept :
      _extents(other.extents()) {

        // TODO:
    }

    template<typename... Indices>
    constexpr size_t operator()(Indices... idx) const noexcept {
      return compute_offset(idx...);
    }

    constexpr Extents extents() const noexcept {
      return _extents;
    }

    constexpr size_t stride(size_t i) const noexcept {
      size_t value = 1;
      for(size_t r = Extents::rank() - 1; r > i; --r)
        value *= _extents.extent(r);
      return value;
    }

    constexpr size_t required_span_size() const noexcept {
      return (1 * ... * _extents.template get<int...(Extents::rank())>());
    }

    static constexpr bool is_always_unique() noexcept { return true; }
    static constexpr bool is_always_contiguous() noexcept { return true; }
    static constexpr bool is_always_strided() noexcept { return true; }
    constexpr bool is_unique() const noexcept { return true; }
    constexpr bool is_contiguous() const noexcept { return true; }
    constexpr bool is_strided() const noexcept { return true; }

    template<class OtherExtents>
    friend constexpr bool operator==(const mapping& lhs, 
      const mapping<OtherExtents>& rhs) noexcept {
      return lhs.extents() == rhs.extents();
    }

    // Not really public, but currently needed to implement fully constexpr useable submdspan:
//   template<size_t N, size_t ... E, size_t ... Idx>
//   constexpr size_type __get_stride(std::experimental::extents<E...>,integer_sequence<size_t, Idx...>) const {
//     return _MDSPAN_FOLD_TIMES_RIGHT((Idx>N? __extents.template __extent<Idx>():1),1);
//   }
//   template<size_t N>
//   constexpr size_type __stride() const noexcept {
//     return __get_stride<N>(__extents, make_index_sequence<extents_type::rank()>());
//   }

  private:
   [[no_unique_address]] Extents _extents;
  };
};

struct layout_left {
  template <class Extents>
  class mapping {
    static_assert(Extents.template == extents, 
        "layout_left::mapping must be instantiated with extents.");

    template <class>
    friend class mapping;

    template<typename... Indices>
    constexpr size_t compute_offset(Indices... indices) const noexcept {
      static_assert(sizeof...(Indices) == Extents::rank());

      // The left-most extent is most quickly varying.
      size_t x = 0;
      @meta for(int i = sizeof... indices - 1; i >= 0; --i) {
        @meta if(i != sizeof... indices - 1)
          x *= _extents.template get<i>();
        x += indices...[i];
      }
      return x;
    }

  public:

    //--------------------------------------------------------------------------------

    constexpr mapping() noexcept = default;
    constexpr mapping(mapping const&) noexcept = default;
    constexpr mapping(mapping&&) noexcept = default;
    mapping& operator=(mapping const&) noexcept = default;
    mapping& operator=(mapping&&) noexcept = default;

    using layout_type = layout_left;
    using extents_type = Extents;
    using size_type = typename Extents::size_type;

    constexpr mapping(const Extents& exts) noexcept
      : _extents(exts) { }

    template<typename OtherExtents>
    requires(std::is_constructible_v<Extents, OtherExtents>)
    explicit(!std::is_convertible_v<OtherExtents, Extents>)
    constexpr mapping(const mapping<OtherExtents>& other) noexcept :
      _extents(other.extents()) { }


    // Convernt from layout_right.
    template<typename OtherMapping>
    requires(
      std::is_constructible_v<Extents, typename OtherMapping::extents_type> &&
      typename OtherMapping::layout_type == layout_right &&
      Extents::rank() <= 1
    )
    explicit(!std::is_convertible_v<typename OtherMapping::extents_type, Extents>)
    constexpr mapping(const OtherMapping& other) noexcept :
      _extents(other.extents()) { }

    // Convert from layout_stride
    template<typename OtherMapping>
    requires(
      std::is_constructible_v<Extents, typename OtherMapping::extents_type> &&
      typename OtherMapping::layout_type == layout_stride
    )
    explicit(Extents::rank() != 0)
    constexpr mapping(const OtherMapping& other) noexcept :
      _extents(other.extents()) {
/*
        // TODO:
       size_t stride = 1;
       for(size_type r=0; r<__extents.rank(); r++) {
         if(stride != other.stride(r))
           throw std::runtime_error("Assigning layout_stride to layout_left with invalid strides.");
         stride *= __extents.extent(r);
*/
    }


    template <typename... Indices>
    constexpr size_type operator()(Indices... idxs) const noexcept {
      return compute_offset(idxs...);
    }

    constexpr Extents extents() const noexcept {
      return _extents;
    }

    constexpr size_type stride(size_t i) const noexcept {
      size_t value = 1;
      for(size_t r = 0; r < i; ++r) 
        value *= _extents.extent(r);
      return value;
    }

    constexpr size_type required_span_size() const noexcept {
      return (1 * ... * _extents.template get<int...(Extents::rank())>());
    }

    static constexpr bool is_always_unique() noexcept { return true; }
    static constexpr bool is_always_contiguous() noexcept { return true; }
    static constexpr bool is_always_strided() noexcept { return true; }

    constexpr bool is_unique() const noexcept { return true; }
    constexpr bool is_contiguous() const noexcept { return true; }
    constexpr bool is_strided() const noexcept { return true; }

    template<class OtherExtents>
    friend constexpr bool operator==(const mapping& lhs, 
      const mapping<OtherExtents>& rhs) noexcept {
      return lhs.extents() == rhs.extents();
    }

  private:
    [[no_unique_address]] Extents _extents;
  };
};

struct layout_stride {
  template <class Extents>
  class mapping {
  public:
    static_assert(Extents.template == extents, 
        "layout_string::mapping must be instantiated with extents.");

    using size_type = typename Extents::size_type;
    using extents_type = Extents;
    using layout_type = layout_stride;

  private:
    //----------------------------------------------------------------------------

    template <class>
    friend class mapping;

  public: 
    constexpr mapping() noexcept = default;
    constexpr mapping(mapping const&) noexcept = default;
    constexpr mapping(mapping&&) noexcept = default;

    template<class IntegralType>
    constexpr mapping(
      const Extents& e,
      const std::array<IntegralType, Extents::rank()>& strides
    ) noexcept
#if defined(_MDSPAN_USE_ATTRIBUTE_NO_UNIQUE_ADDRESS)
      : __members{
#else
      : __base_t(__base_t{__member_pair_t(
#endif
          e, __strides_storage_t{strides}
#if defined(_MDSPAN_USE_ATTRIBUTE_NO_UNIQUE_ADDRESS)
        }
#else
        )})
#endif
    { }

    template<class OtherExtents>
    MDSPAN_CONDITIONAL_EXPLICIT((!is_convertible<OtherExtents, Extents>::value)) // needs two () due to comma
    MDSPAN_INLINE_FUNCTION
    constexpr
    mapping(
      const mapping<OtherExtents>& rhs
    ) noexcept
#if defined(_MDSPAN_USE_ATTRIBUTE_NO_UNIQUE_ADDRESS)
      : __members{
#else
      : __base_t(__base_t{__member_pair_t(
#endif
          rhs.extents(), __strides_storage_t{rhs.__strides_storage()}
#if defined(_MDSPAN_USE_ATTRIBUTE_NO_UNIQUE_ADDRESS)
        }
#else
        )})
#endif
    { }


    MDSPAN_TEMPLATE_REQUIRES(
      class OtherMapping,
      /* requires */ (
        _MDSPAN_TRAIT(is_constructible, Extents, typename OtherMapping::extents_type) &&
        _MDSPAN_TRAIT(is_same, typename OtherMapping::layout_type::template mapping<typename OtherMapping::extents_type>, OtherMapping) &&
        OtherMapping::is_always_unique() &&
        OtherMapping::is_always_strided()
      )
    )
    MDSPAN_CONDITIONAL_EXPLICIT((!is_convertible<typename OtherMapping::extents_type, Extents>::value)) // needs two () due to comma
    MDSPAN_INLINE_FUNCTION _MDSPAN_CONSTEXPR_14
    mapping(OtherMapping const& other) noexcept // NOLINT(google-explicit-constructor)
#if defined(_MDSPAN_USE_ATTRIBUTE_NO_UNIQUE_ADDRESS)
      : __members{
#else
      : __base_t(__base_t{__member_pair_t(
#endif
          other.extents(), __strides_storage_t(__impl::fill_strides(other))
#if defined(_MDSPAN_USE_ATTRIBUTE_NO_UNIQUE_ADDRESS)
        }
#else
        )})
#endif
    {}

    //--------------------------------------------------------------------------------

    MDSPAN_INLINE_FUNCTION constexpr extents_type extents() const noexcept {
#if defined(_MDSPAN_USE_ATTRIBUTE_NO_UNIQUE_ADDRESS)
      return __members.__first();
#else
      return this->__base_t::__ref().__first();
#endif
    };

    MDSPAN_INLINE_FUNCTION constexpr bool is_unique() const noexcept { return true; }
    MDSPAN_INLINE_FUNCTION _MDSPAN_CONSTEXPR_14 bool is_contiguous() const noexcept {
      // TODO @testing test layout_stride is_contiguous()

      auto rem = array<size_t, Extents::rank()>{ };
      std::iota(rem.begin(), rem.end(), size_t(0));
      auto next_idx_iter = std::find_if(
        rem.begin(), rem.end(),
        [&](size_t i) { return this->stride(i) == 1;  }
      );
      if(next_idx_iter != rem.end()) {
        size_t prev_stride_times_prev_extent =
          this->extents().extent(*next_idx_iter) * this->stride(*next_idx_iter);
        // "remove" the index
        constexpr size_t removed_index_sentinel = -1;
        *next_idx_iter = removed_index_sentinel;
        int found_count = 1;
        while (found_count != Extents::rank()) {
          next_idx_iter = std::find_if(
            rem.begin(), rem.end(),
            [&](size_t i) {
              return i != removed_index_sentinel
                && this->extents().extent(i) == prev_stride_times_prev_extent;
            }
          );
          if (next_idx_iter != rem.end()) {
            // "remove" the index
            *next_idx_iter = removed_index_sentinel;
            ++found_count;
            prev_stride_times_prev_extent = stride(*next_idx_iter) * this->extents().extent(*next_idx_iter);
          } else { break; }
        }
        return found_count == Extents::rank();
      }
      return false;
    }
    MDSPAN_INLINE_FUNCTION constexpr bool is_strided() const noexcept { return true; }

    MDSPAN_INLINE_FUNCTION static constexpr bool is_always_unique() noexcept { return true; }
    MDSPAN_INLINE_FUNCTION static constexpr bool is_always_contiguous() noexcept {
      return false;
    }
    MDSPAN_INLINE_FUNCTION static constexpr bool is_always_strided() noexcept { return true; }

    MDSPAN_TEMPLATE_REQUIRES(
      class... Indices,
      /* requires */ (
        sizeof...(Indices) == Extents::rank() &&
        _MDSPAN_FOLD_AND(_MDSPAN_TRAIT(is_constructible, Indices, size_t) /*&& ...*/)
      )
    )
    MDSPAN_FORCE_INLINE_FUNCTION
    constexpr size_t operator()(Indices... idxs) const noexcept {
      return __impl::_call_op_impl(*this, idxs...);
    }

    MDSPAN_INLINE_FUNCTION
    constexpr size_t stride(size_t r) const noexcept {
      return __strides_storage().extent(r);
    }

    MDSPAN_INLINE_FUNCTION
    constexpr array< size_t, Extents::rank() > strides() const noexcept {
      return __strides(std::make_index_sequence<Extents::rank()>());
    }

    MDSPAN_INLINE_FUNCTION
    constexpr size_t required_span_size() const noexcept {
      size_t span_size = 1;
      for(unsigned r = 0; r < Extents::rank(); r++) {
        // Return early if any of the extents are zero
        if(extents().extent(r)==0) return 0;
        span_size = std::max(span_size, extents().extent(r) * __strides_storage().extent(r));
      }
      return span_size;
    }

    template<class OtherExtents>
    MDSPAN_INLINE_FUNCTION
    friend constexpr bool operator==(mapping const& lhs, mapping<OtherExtents> const& rhs) noexcept {
      return __impl::_eq_impl(lhs, rhs);
    }

#if MDSPAN_HAS_CXX_20
    template<class OtherExtents>
    MDSPAN_INLINE_FUNCTION
    friend constexpr bool operator!=(mapping const& lhs, mapping<OtherExtents> const& rhs) noexcept {
      return __impl::_not_eq_impl(lhs, rhs);
    }
#endif

  };
};

////////////////////////////////////////////////////////////////////////////////

template <class ElementType>
struct default_accessor {
  using offset_policy = default_accessor;
  using element_type = ElementType;
  using reference = ElementType&;
  using pointer = ElementType*;

  constexpr default_accessor() noexcept = default;

  template<typename OtherElementType>
  requires(std::is_convertible_v<OtherElementType(*)[], element_type(*)[]>)
  constexpr default_accessor(default_accessor<OtherElementType>) noexcept { }

  constexpr pointer offset(pointer p, size_t i) const noexcept {
    return p + i;
  }

  constexpr reference access(pointer p, size_t i) const noexcept {
    return p[i];
  }
};

////////////////////////////////////////////////////////////////////////////////

template <
  class ElementType,
  class Extents,
  class Layout = layout_right,
  class Accessor = default_accessor<ElementType>
>
class mdspan {
  static_assert(extents == Extents.template, 
    "Extents parameter must be a specialization of extents");

public:
  using extents_type = Extents;
  using layout_type = Layout;
  using accessor_type = Accessor;
  using mapping_type = typename layout_type::template mapping<extents_type>;
  using element_type = ElementType;
  using value_type = element_type.remove_cv;
  using size_type = size_t;
  using difference_type = ptrdiff_t;
  using pointer = typename accessor_type::pointer;
  using reference = typename accessor_type::reference;

  constexpr mdspan() = default;
  constexpr mdspan(const mdspan&) = default;
  constexpr mdspan(mdspan&&) = default;

  template<SizeType... IndexTypes>
  requires(
    std::is_constructible_v<extents_type, IndexTypes...> &&
    std::is_constructible_v<mapping_type, extents_type> &&
    std::is_default_constructible_v<accessor_type>
  )
  explicit constexpr mdspan(pointer p, IndexTypes... dynamic_extents) : 
    _pointer(p), _mapping(extents_type(dynamic_extents...)) { }

  template<SizeType IndexType, size_t N>
  requires(
    std::is_constructible_v<extents_type, array<IndexType, N> > &&
    std::is_constructible_v<mapping_type, extents_type> &&
    std::is_default_constructible_v<accessor_type>
  ) 
  explicit(N != extents_type::rank_dynamic())
  constexpr mdspan(pointer p, const array<IndexType, N>& dynamic_extents)
    : _pointer(p), _mapping(extents_type(dynamic_extents)) { }

  constexpr mdspan(pointer p, const extents_type& exts) requires(
    std::is_constructible<mapping_type, extents_type> &&
    std::is_default_constructible_v<accessor_type>
  ) : _pointer(p), _mapping(exts) { }

  constexpr mdspan(pointer p, const mapping_type& m) 
  requires(std::is_default_constructible_v<accessor_type>) : 
    _pointer(p), _mapping(m) { }

  constexpr mdspan(pointer p, const mapping_type& m, const accessor_type& a)
    : _pointer(p), _mapping(m), _accessor(a) { }

  template<
    typename ElementType2, typename Extents2, 
    typename Layout2, typename Accessor2
  > requires(
    std::is_constructible_v<mapping_type, template Layout2::template mapping<Extents2> > &&
    std::is_constructible_v<accessor_type, Accessor2> &&
    std::is_constructible_v<pointer, typename Accessor2::pointer> &&
    std::is_constructible_v<extents_type, Extents2>
  )
  constexpr mdspan(mdspan<ElementType2, Extents2, Layout2, Accessor>& other) :
    _pointer(other._pointer), _mapping(other.__mapping), 
    _accessor(other._accessor) { }

  // Indexing.
  template<SizeType... IndexTypes>
  requires(extents_type::rank() == sizeof...(IndexTypes))
  constexpr reference operator[](IndexTypes... indices) const noexcept {
    return _accessor.access(_pointer, _mapping(size_type(indices)...));
  }

  template<SizeType IndexType, size_t N>
  requires(N == extents_type::rank())
  constexpr reference operator[](const array<IndexType, N>& indices) const noexcept {
    return _accessor.access(_pointer, _mapping(indices));
  }

  template<SizeType... IndexTypes>
  requires(extents_type::rank() == sizeof...(IndexTypes))
  constexpr reference operator()(IndexTypes... indices) const noexcept {
    return _accessor.access(_pointer, _mapping(size_type(indices)...));
  }

  template<SizeType IndexType, size_t N>
  requires(N == extents_type::rank())
  constexpr reference operator()(const array<IndexType, N>& indices) const noexcept {
    return _accessor.access(_pointer, _mapping(indices));
  }

  constexpr accessor_type accessor() const { return _accessor; };

  static constexpr size_t rank() noexcept { return extents_type::rank(); }
  static constexpr size_t rank_dynamic() noexcept { return extents_type::rank_dynamic(); }
  static constexpr size_type static_extent(size_t r) noexcept { return extents_type::static_extent(r); }

  constexpr extents_type extents() const noexcept { return _mapping.extents(); };
  constexpr size_type extent(size_t r) const noexcept { return _mapping.extents().extent(r); };
  constexpr size_type size() const noexcept {
    return (1 * ... * extents().template extent<int...(extents_type::rank())>);
  };

  constexpr pointer data() const noexcept { return _pointer; };

  static constexpr bool is_always_unique() noexcept { return mapping_type::is_always_unique(); };
  static constexpr bool is_always_contiguous() noexcept { return mapping_type::is_always_contiguous(); };
  static constexpr bool is_always_strided() noexcept { return mapping_type::is_always_strided(); };

  constexpr mapping_type mapping() const noexcept { return _mapping; }
  constexpr bool is_unique() const noexcept { return _mapping.is_unique(); };
  constexpr bool is_contiguous() const noexcept { return _mapping.is_contiguous(); };
  constexpr bool is_strided() const noexcept { return _mapping.is_strided(); };
  constexpr size_type stride(size_t r) const { return _mapping.stride(r); };

private:

  pointer _pointer;
  [[no_unique_address]] mapping_type _mapping;
  [[no_unique_address]] accessor_type _accessor;

  template <class, class, class, class>
  friend class mdspan;
};

#if defined(_MDSPAN_USE_CLASS_TEMPLATE_ARGUMENT_DEDUCTION)
MDSPAN_TEMPLATE_REQUIRES(
  class ElementType, class... SizeTypes,
  /* requires */ _MDSPAN_FOLD_AND(_MDSPAN_TRAIT(is_integral, SizeTypes) /* && ... */)
)
mdspan(ElementType*, SizeTypes...)
  -> mdspan<ElementType, ::std::experimental::dextents<sizeof...(SizeTypes)>>;

template <class ElementType, class SizeType, size_t N>
mdspan(ElementType*, const ::std::array<SizeType, N>&)
  -> mdspan<ElementType, ::std::experimental::dextents<N>>;

template <class ElementType, size_t... ExtentsPack>
mdspan(ElementType*, const extents<ExtentsPack...>&)
  -> mdspan<ElementType, ::std::experimental::extents<ExtentsPack...>>;

template <class ElementType, class MappingType>
mdspan(ElementType*, const MappingType&)
  -> mdspan<ElementType, typename MappingType::extents_type, typename MappingType::layout_type>;

template <class MappingType, class AccessorType>
mdspan(const typename AccessorType::pointer, const MappingType&, const AccessorType&)
  -> mdspan<typename AccessorType::element_type, typename MappingType::extents_type, typename MappingType::layout_type, AccessorType>;
#endif

}
}

#define _MDSPAN_INLINE_VARIABLE inline
#define MDSPAN_INLINE_FUNCTION inline